// func retryHandler(retry <-chan *RequestSend, cancel chan struct{}, job chan *RequestSend, clients []*http.Client, headers []*http.Header, ) {
// 	for {
// 		select {
// 		case item := <-retry:
// 			switch {
// 			case item.Caught:
// 				job <- item
// 				break
// 			case item.Retries == 0:
// 				break
// 			default:
// 				job <- item
// 				break
// 			}
// 		case <-cancel:
// 			return
// 		}
// 	}
// }

// func addToRS(rc *RequestCollection, rs <-chan *RequestSend) {
// 	for items := range rs {
// 		rc.AddRS(items)
// 	}
// }



// func completeCriterion(retry chan *RequestSend, rj *RequestCollection, result *RequestResult, cancel *chan struct{}, end *chan struct{}, wg *sync.WaitGroup) {
// 	cHeader := 0
// 	cClient := 0
// 	for {
// 		select {
// 		// Handling retries
// 		case item := <-retry:
// 			switch {
// 			case item.Caught:
// 				cHeader = changeHeaders(item.Request.Request, rj.RJ, cHeader)
// 				wg.Add(1)
// 				go HandleRequest(item, retry, result, wg)
// 				break
// 			case item.Retries == 0:
// 				break
// 			default:
// 				cClient = changeClient(item.Client, rj.RJ.Clients, cClient)
// 				wg.Add(1)
// 				go HandleRequest(item, retry, result, wg)
// 			}

// 			break
// 		case <-*cancel:
// 			return
// 		case <-*end:
// 			return
// 		}
// 	}
// }


func simpleCriteriaCheck(rc *RequestCollection) {

}

func simpleCriterion(cancel *chan struct{}, finish *chan struct{}, retry <-chan *RequestSend) {
	for {
		select {
		case <-*cancel:
			return
		case <-*finish:
			return
		case <-retry:
			break
		}
	}
}


/*Worker Groups*/

func Worker(jobs <-chan *RequestSend, enforce bool, retry chan *RequestSend, cancel chan struct{}, rr *RequestResult, ms *MutexSend, wg *sync.WaitGroup) {
	for {
		select {
		case items := <-jobs:
			wg.Add(1)
			go HandleRequest(enforce, items, retry, rr, ms, wg)
			break
		case <-cancel:
			return
		}
	}
}

func QueuedWorker(jobs <-chan *RequestSend, enforce bool, retry chan *RequestSend, cancel chan struct{}, rr *RequestResult, ms *MutexSend, wg *sync.WaitGroup) {
	for {
		select {
		case items := <-jobs:
			wg.Add(1)
			HandleRequest(enforce, items, retry, rr, ms, wg)
			break
		case <-cancel:
			return
		}
	}
}

/*Cleaners*/

// func CleanRS(retry chan *RequestSend) {
// 	for items := range retry {
// 		fmt.Println(items)
// 	}
// 	return
// }




// func CreateNewRequest(method string, url string, body io.Reader) *http.Request {
// 	req, err := http.NewRequest(method, url, body)
// 	if err != nil {
// 		log.Println(err)
// 	}

// 	return req
// }

// func SimpleNoContextSetup(urls []string, timeout time.Duration, method func(rp ResultPackage) bool) *RequestCollection {
// 	rs := make([]*RequestSend, 0, len(urls))
// 	req := ConvertToURL(urls)

// 	ri := CreateLinkRequestContext(req)
// 	for _, x := range ri {

// 		rs = append(rs, &RequestSend{
// 			Request: x,
// 			Method:  method,
// 			Client:  &http.Client{},
// 		})
// 	}

// 	return &RequestCollection{
// 		RS: rs,
// 	}
// }