// func retryHandler(retry <-chan *RequestSend, cancel chan struct{}, job chan *RequestSend, clients []*http.Client, headers []*http.Header, ) {
// 	for {
// 		select {
// 		case item := <-retry:
// 			switch {
// 			case item.Caught:
// 				job <- item
// 				break
// 			case item.Retries == 0:
// 				break
// 			default:
// 				job <- item
// 				break
// 			}
// 		case <-cancel:
// 			return
// 		}
// 	}
// }

// func addToRS(rc *RequestCollection, rs <-chan *RequestSend) {
// 	for items := range rs {
// 		rc.AddRS(items)
// 	}
// }



// func completeCriterion(retry chan *RequestSend, rj *RequestCollection, result *RequestResult, cancel *chan struct{}, end *chan struct{}, wg *sync.WaitGroup) {
// 	cHeader := 0
// 	cClient := 0
// 	for {
// 		select {
// 		// Handling retries
// 		case item := <-retry:
// 			switch {
// 			case item.Caught:
// 				cHeader = changeHeaders(item.Request.Request, rj.RJ, cHeader)
// 				wg.Add(1)
// 				go HandleRequest(item, retry, result, wg)
// 				break
// 			case item.Retries == 0:
// 				break
// 			default:
// 				cClient = changeClient(item.Client, rj.RJ.Clients, cClient)
// 				wg.Add(1)
// 				go HandleRequest(item, retry, result, wg)
// 			}

// 			break
// 		case <-*cancel:
// 			return
// 		case <-*end:
// 			return
// 		}
// 	}
// }


func simpleCriteriaCheck(rc *RequestCollection) {

}

func simpleCriterion(cancel *chan struct{}, finish *chan struct{}, retry <-chan *RequestSend) {
	for {
		select {
		case <-*cancel:
			return
		case <-*finish:
			return
		case <-retry:
			break
		}
	}
}


/*Worker Groups*/

func Worker(jobs <-chan *RequestSend, enforce bool, retry chan *RequestSend, cancel chan struct{}, rr *RequestResult, ms *MutexSend, wg *sync.WaitGroup) {
	for {
		select {
		case items := <-jobs:
			wg.Add(1)
			go HandleRequest(enforce, items, retry, rr, ms, wg)
			break
		case <-cancel:
			return
		}
	}
}

func QueuedWorker(jobs <-chan *RequestSend, enforce bool, retry chan *RequestSend, cancel chan struct{}, rr *RequestResult, ms *MutexSend, wg *sync.WaitGroup) {
	for {
		select {
		case items := <-jobs:
			wg.Add(1)
			HandleRequest(enforce, items, retry, rr, ms, wg)
			break
		case <-cancel:
			return
		}
	}
}

/*Cleaners*/

// func CleanRS(retry chan *RequestSend) {
// 	for items := range retry {
// 		fmt.Println(items)
// 	}
// 	return
// }




// func CreateNewRequest(method string, url string, body io.Reader) *http.Request {
// 	req, err := http.NewRequest(method, url, body)
// 	if err != nil {
// 		log.Println(err)
// 	}

// 	return req
// }

// func SimpleNoContextSetup(urls []string, timeout time.Duration, method func(rp ResultPackage) bool) *RequestCollection {
// 	rs := make([]*RequestSend, 0, len(urls))
// 	req := ConvertToURL(urls)

// 	ri := CreateLinkRequestContext(req)
// 	for _, x := range ri {

// 		rs = append(rs, &RequestSend{
// 			Request: x,
// 			Method:  method,
// 			Client:  &http.Client{},
// 		})
// 	}

// 	return &RequestCollection{
// 		RS: rs,
// 	}
// }

// package req

// import (
// 	"fmt"
// 	"sync"
// )

// // A circular queue that implements a linear queue for further Scraping
// type Queue struct {
// 	mu         sync.RWMutex
// 	List       []*Send
// 	front, pop int
// 	extend     *LinearQueue
// }

// func (q *Queue) New(length int) *Queue {
// 	return &Queue{
// 		List:  make([]*Send, 0, length),
// 		front: 0,
// 		pop:   0,
// 	}
// }

// func (q *Queue) Make(rs []*Send) *Queue {
// 	q.List = rs
// 	q.front = 0
// 	q.pop = 0
// 	return q
// }

// func (q *Queue) Add(rs *Send) bool {
// 	q.mu.Lock()
// 	defer q.mu.Unlock()
// 	// Check if the current position is empty
// 	if q.List[q.front] == nil {
// 		q.List[q.front] = rs
// 		q.front++
// 		// check if the next position is ok
// 		if q.front == len(q.List) {
// 			q.front = 0
// 		}
// 		return true
// 	} else if q.extend != nil {
// 		q.extend.Add(rs)
// 	}

// 	return false
// }

// func (q *Queue) Pop() *Send {
// 	q.mu.Lock()
// 	defer q.mu.Unlock()
// 	// we want to pop a non empty object
// 	if q.List[q.pop] != nil {
// 		temp := q.List[q.pop]
// 		q.List[q.pop] = nil
// 		q.pop++
// 		if q.pop == len(q.List) {
// 			q.pop = 0
// 		}
// 		return temp
// 	} else if q.extend != nil {
// 		q.extend.Pop()
// 	}

// 	return nil
// }

// func (q *Queue) View() {
// 	q.mu.RLock()
// 	defer q.mu.RUnlock()
// 	fmt.Println("(CQ) List: ", q.List)
// 	fmt.Println("(LQ) List: ", q.List)
// }

// func (q *Queue) Extend(size int) {
// 	q.extend = &LinearQueue{
// 		list: make([]*Send, 0, size),
// 	}
// }