package main

import (
	"fmt"
	"log"
	"os"
	"runtime"
	"runtime/pprof"
	"time"

	"github.com/taahakh/speed"
	"github.com/taahakh/speed/req"
)

var cou int

type Storing struct {
	Text string
}

func finished(p req.PoolLook) {
	pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)
	p.Close()
	pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)
}

func scr(rp req.Result) bool {
	rp.Save(Storing{
		Text: rp.Document().Node.Text(),
	})
	rp.Scrape(func(rp req.Result) bool {
		rp.Save(Storing{
			Text: rp.Document().Node.Text(),
		})
		return true
	}, "https://httpbin.org/ip")

	return true
}

func whenDone(rc *req.Collection) {
	fmt.Println("Im done")
	pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)
	for _, x := range rc.Result.Read() {
		switch v := x.(type) {
		case Storing:
			convert := x.(Storing)
			fmt.Println("CONVERTED: ", convert.Text[0])
			break
		default:
			log.Println("Couldn't cast. Interface is -> ", v)
		}
	}
}

func con(str Storing) Storing {
	str.Text = "changed"
	return str
}

func main() {

	mess := make([]interface{}, 0)
	fmt.Println(mess)

	csv, err := speed.ReadCSV("C:\\Users\\taaha\\go\\src\\github.com\\taahakh\\speed\\data\\req\\list.csv")
	if err != nil {
		log.Println("There is no file")
	}
	fmt.Println(csv[0])
	dur, err := time.ParseDuration("3s")
	if err != nil {
		log.Println(err)
	}
	fmt.Println(dur)

	ok := req.Send{}
	fmt.Println("Caught: ", ok.Caught)

	// rj1 := req.ProxySetup(
	// 	req.GenodeRead(csv, "http"),
	// 	[]string{
	// 		"https://httpbin.org/ip",
	// 		"https://httpbin.org/ip",
	// 	},
	// 	nil,
	// 	2,
	// 	dur,
	// 	scr,
	// )

	rj2 := req.ProxySetup(
		req.GenodeRead(csv, "http"),
		[]string{
			"https://httpbin.org/ip",
			"https://httpbin.org/ip",
		},
		nil,
		2,
		dur,
		scr,
	)

	rj1 := req.NoProxy(
		[]string{
			"https://httpbin.org",
			"https://httpbin.org/ip",
		},
		dur,
		scr,
	)

	// go func() {
	// 	for {
	// 		time.Sleep(time.Second * 5)
	// 		fmt.Println("Goroutines: ", runtime.NumGoroutine())
	// 	}
	// }()

	// req.Batch(rj1, 11, "2s")
	// req.Simple(rj1)
	// req.CompleteSession(rj1, nil)
	// time.Sleep(time.Second * 4)
	// pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)

	// for i, x := range rj1.Result.Read() {
	// 	deref := *x
	// 	fmt.Println("Count: ", i, "Text: ", deref.(Storing))
	// }

	// pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)

	pool := req.Pool{}
	pool.New("main", req.PoolSettings{
		IncomingCompletedCollections: whenDone,
		AllCollectionsCompleted:      finished,
	})

	pool.Add("A", rj1)
	pool.Add("B", rj2)

	// arr2 := []string{"testing 123"}

	// r, err := cli1.Do(rj1.RS[0].Request.Request)
	// if err != nil {
	// 	log.Println(err)
	// } else {
	// 	fmt.Println(r)
	// }
	// go cli1.Do(rj1.RS[1].Request.Request)
	// pool.Run("A", req.Method_Simple, 2)
	// pool.Run("B", req.Method_Simple, 2)
	// lol2 := pool.BlockUntilComplete("B")
	// fmt.Println(lol2)
	// lol := pool.BlockUntilComplete("A")[0]
	// fmt.Println(lol)
	// time.Sleep(time.Second * 30)
	// pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)
	// time.Sleep(time.Millisecond * 1000)
	// time.Sleep(time.Second * 10)
	// pool.Close()
	// pool.Run("A", req.Method_Complete, 2)

	// for i := 0; i < 3; i++ {
	// 	time.Sleep(time.Second * 2)
	// 	fmt.Println(i, runtime.NumGoroutine())
	// 	// fmt.Println("Finished list: ", pool.GetFinishedList())
	// }

	// pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)

	// for {
	// 	time.Sleep(time.Second * 5)
	// 	fmt.Println("Goroutines: ", runtime.NumGoroutine())
	// }

	// pool.Close()

	// _, failed := pool.CancelCollection("A")
	// fmt.Println("Pool collection status: ", failed)
	// pool.Close()

	for {
		time.Sleep(time.Second * 2)
		fmt.Println("Goroutines: ", runtime.NumGoroutine())
	}
}
