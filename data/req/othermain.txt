package main

import (
	"fmt"
	"log"
	"os"
	"runtime"
	"runtime/pprof"
	"time"

	"github.com/taahakh/speed"
	"github.com/taahakh/speed/req"
)

const (
	cacheLoc = "./cache.gob"
)

type Storing struct {
	Text string
}

func successful(rp req.Result) bool {
	rp.Save(Storing{
		Text: rp.Document().Node.Text(),
	})
	rp.Scrape(nil, "https://httpbin.org/ip")

	return true
}

func whenDone(rc *req.Collection) {
	for _, x := range rc.Result.Read() {
		item := *x
		switch v := item.(type) {
		case Storing:
			convert := item.(Storing)
			fmt.Println("CONVERTED: ", convert.Text[0])
			break
		default:
			log.Println("Couldn't cast. Interface is -> ", v)
		}
	}
}

func main() {
	dur, err := time.ParseDuration("10s")
	if err != nil {
		log.Println(err)
	}
	csv, err := speed.ReadCSV("/Users/taaha/go/src/github.com/taahakh/speed/data/req/a.csv")
	csv2, err := speed.ReadCSV("/Users/taaha/go/src/github.com/taahakh/speed/data/req/b.csv")
	if err != nil {
		log.Fatal("ok")
	}
	fmt.Println(csv2[0])
	fmt.Println(dur)
	fmt.Println(runtime.NumGoroutine())
	fmt.Println(csv[0])

	fmt.Println(dur == 0)
	// rc := req.ProxySetup(
	// 	req.GenodeRead(csv, "http"),
	// 	// nil,
	// 	[]string{
	// 		"https://httpbin.org",
	// 		// "https://ruktaj.co.uk",
	// 		"https://httpbin.org/ip",
	// 	},
	// 	nil,
	// 	1,
	// 	dur,
	// 	scr,
	// )

	// rc := req.ProxySetup(
	// 	// req.SingleList(csv2, "http"),
	// 	req.GenodeRead(csv, "http"),
	// 	[]string{
	// 		"https://httpbin.org",
	// 		"https://httpbin.org/ip",
	// 		"https://httpbin.org/ip",
	// 		"https://httpbin.org/ip",
	// 	},
	// 	nil,
	// 	1,
	// 	dur,
	// 	successful,
	// )

	rc := req.NoProxy(
		[]string{
			"https://httpbin.org",
			"https://httpbin.org/ip",
		},
		dur,
		successful,
	)

	// rc1 := req.SimpleSetup(
	// 	[]string{
	// 		"https://httpbin.org",
	// 		// "https://ruktaj.co.uk",
	// 		"https://httpbin.org/ip",
	// 	},
	// 	dur,
	// 	scr,
	// )
	// fmt.Println(rc1)
	fmt.Println(rc)

	// cc := req.Cache{}.New()
	// cc.Load(cacheLoc)

	// req.CompleteSession(rc)
	req.Simple(rc)
	// fmt.Println(rc.Result.Read())
	time.Sleep(time.Second * 5)
	// pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)
	// if false {
	pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)

	pool := req.Pool{}
	pool.New("pool", req.PoolSettings{
		IncomingCompletedCollections: whenDone,
		// Cache:                        *cc,
	})
	pool.Add("new", rc)
	pool.Close()
	// }

	// pool.Add("new1", rc1)

	// pool.Run("new", req.Method_Complete, 2)
	// please := pool.BlockUntilComplete("new")
	// fmt.Println(please)

	// cc.Add("1", traverse.HTMLDocument{})
	// cc.Add("2", traverse.HTMLDocument{})
	// cc.Add("1")
	// cc.Add("2")
	// cc.Save(cacheLoc)

	// fmt.Println(cc)
	time.Sleep(time.Second * 5)
	// pool.Close()
	pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)

	// fmt.Println(pool.AmIDone("new"))

	for {
		time.Sleep(time.Second * 10)
		fmt.Println("Routine: ", runtime.NumGoroutine())
		// fmt.Println(pool.AmIDone("new"))
		// pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)
	}
}
