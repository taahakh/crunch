package speed

import (
	"bytes"
	"io"
	"strings"

	"golang.org/x/net/html"
)

type Attribute struct {
	Name  string
	Value string
}

type NodeList struct {
	Node []Node
}

type Node struct {
	Node *html.Node
}

// Not efficient and takes in Search struct as parameters to automatically search for the correct Nodes
func AdvancedSearch(r *html.Node, s Search, l *Tag) {

	// Search function that carries out checks for attributes
	// appends to node struct to then be appended to another struct called Tag
	// Tag keep all data associated to the to this one struct
	// Search and Tag works on per HTML Doc basis

	var search = func() {
		temp := []Node{}
		for i := 0; i < len(r.Attr); i++ {
			attr := r.Attr[i]
			if compareWithSearch(attr, s, r) {
				// l.Node = append(l.Node, []Node{{Node: r}})
				temp = append(temp, Node{Node: r})
			}
		}

		if len(temp) > 0 {
			l.Node = append(l.Node, temp)
			temp = nil
		}
	}

	func() {
		if r.Type == html.ElementNode {
			// checks if a tag exists
			if len(s.Tag) > 0 {
				// check if the tag equals to the data
				if r.Data == s.Tag {
					// checks if the tag is accompanied with attributes/ selectors
					if len(s.Attr) > 0 || len(s.Selector) > 0 {
						search()
					} else { // appends all named tag that has been chosen
						l.Node = append(l.Node, []Node{{Node: r}})
					}
				}
			} else { // used if only attr are present for the search
				search()
			}
		}

		// doing a depth first search
		for c := r.FirstChild; c != nil; c = c.NextSibling {
			AdvancedSearch(c, s, l)
		}
	}()

	// fmt.Println(sc)
}

func compareAttrandValue(attr html.Attribute, s SearchSpecifc) bool {
	if val, ok := s.Attr[attr.Key]; ok {
		if words := strings.Fields(attr.Val); len(words) > 1 {
			for _, x := range words {
				if x == val {
					return true
				}
			}
		}
		if attr.Val == val {
			return true
		}
	}
	return false
}

func compareWithAttributeList(r *html.Node, a []Attribute) bool {
	for _, x := range a {
		for _, y := range r.Attr {
			if len(x.Value) > 0 {
				if x.Name == y.Key {
					if words := strings.Fields(y.Val); len(words) > 0 {
						for _, z := range words {
							if x.Value == z {
								return true
							}
						}
					}
				}
			}

		}
	}

	return false
}

func compareWithSearch(attr html.Attribute, s Search, r *html.Node) bool {

	var attrSearch = func(as []Attribute) bool {
		for _, val := range as {
			// if key exists
			if val.Name == attr.Key {
				// if value exists
				if len(val.Value) > 0 {
					// search through attributes
					if words := strings.Fields(attr.Val); len(words) > 0 {
						// splits atrribute values
						for _, y := range words {
							if val.Value == y {
								return true
							}
						}
					}
					// return searchAttr(attr, val.Value)
				} else {
					return true
				}
			}
		}
		return false
	}

	var search = func() bool {

		// if a selector is present
		if len(s.Selector) > 0 {
			// if the selector belong in the document
			if attrSearch(s.Selector) {
				// checks is we need to check for attributes
				if len(s.Attr) > 0 {
					// returns false if the selector and attr don't match
					// we need the node parent for this so we can
					// continue with the search. this is partially broken
					// return attrSearch(s.Attr)
					return compareWithAttributeList(r, s.Attr)
					// return true
				} else {
					return true
				}
			}
			return false
		}

		// for tag + attributes if it has branched off the tag way
		// see if there is attributes that we want to look for
		if len(s.Attr) > 0 {
			return attrSearch(s.Attr)
		}
		return false
	}

	// returns true when only the tag is present
	if len(s.Tag) > 0 && len(s.Attr) == 0 && len(s.Selector) == 0 {
		return true
	}

	return search()
}

func searchAttr(attr html.Attribute, val string, num_selector ...int) bool {
	words := strings.Fields(attr.Val)
	// if num_selector != nil {
	// 	if num_selector[0] != len(words) {
	// 		return false
	// 	}
	// }

	if len(words) > 0 {
		for _, x := range words {
			if !(x == val) {
				return false
			}
		}
		return true
	}
	return false
}

func strictCompare(r []html.Attribute, s Search) bool {
	var s_count, a_count int

	s_count = len(s.Selector)
	a_count = len(s.Attr)
	num_selector := s_count

	// fmt.Println("s: ", s_count)
	// fmt.Println("a: ", a_count)

	if s_count > 0 && !(s_count+a_count == len(r)) {
		return false
	}

	// iterating through the nodes attr list
	for _, x := range r {
		// iterating through the selector list we have chosen
		for _, y := range s.Selector {
			// fmt.Println(y)
			// checking if the attr selector exists class/id
			if y.Name == x.Key {
				// if the selector has a value associated with it
				// so the class name/id name
				if len(y.Value) > 0 {
					if searchAttr(x, y.Value, num_selector) {
						s_count--
					}
					// once we have found it we found the key-pair or not we want to continue
					continue
				} else {
					// this is where there is no value associated with the key
					s_count--
				}
			}
		}

		// we going to check if attr list has been given
		if a_count > 0 {
			//  we check if the right length of attributes in html
			// and search attributes/selectors are the same
			if len(r) == len(s.Selector)+len(s.Attr) {
				// loop through the attributes we want to strictly find
				for _, z := range s.Attr {
					// if we found the correct keypair then we increment the counter
					if searchAttr(x, z.Value) {
						a_count--
					}
				}
			}

		}

	}

	//  we are decrementing the count and it should not be higher nor lower than zero
	if s_count == 0 && a_count == 0 {
		return true
	} else {
		return false
	}

}

func strictAttrCompare(r *html.Node, s Search, l *Tag) {
	count := len(s.Attr)
	for _, x := range r.Attr {
		for _, y := range s.Attr {
			if y.Name == x.Key {
				if y.Value == x.Val {
					count--
				}
			}
		}
	}
	if count == 0 {
		l.Node = append(l.Node, []Node{{Node: r}})
	}
}

func strictSearch(r *html.Node, s Search, l *Tag) {
	if strictCompare(r.Attr, s) {
		l.Node = append(l.Node, []Node{{Node: r}})
	}

}

func findStrictlySearch(r *html.Node, s Search, l *Tag) {
	isTag := len(s.Tag) > 0
	isSelector := len(s.Selector) > 0

	// check if it's an element node
	if r.Type == html.ElementNode {
		// check if it equals the tag
		if isTag {
			// current node is equal to our tag?
			if r.Data == s.Tag {
				strictSearch(r, s, l)
			}
		} else if isSelector {
			// runs when only selector present
			strictSearch(r, s, l)
		} else {
			strictAttrCompare(r, s, l)
		}
	}

	for c := r.FirstChild; c != nil; c = c.NextSibling {
		findStrictlySearch(c, s, l)
	}

}

func findStrictly(r *html.Node, s Search, l *Tag) {
	findStrictlySearch(r, s, l)
}

//  HTML parsing. Independeant from the DocumentGroup

func Parse(r io.Reader) (*html.Node, error) {
	return html.Parse(r)
}

func EasyParse(s *[]byte) (*html.Node, error) {
	return html.Parse(bytes.NewReader(*s))
}

func qS(r []html.Attribute, s Search) bool {

	numToBeFound := len(s.Attr)
	for _, x := range r {
		for _, y := range s.Attr {
			if y.Name == x.Key {
				if y.Value == x.Val {
					numToBeFound--
				}
			}
		}
	}

	return numToBeFound == 0
}

// func qSCompare(r *html.Node, s Search, l *NodeList) {
// 	if qS(r.Attr, s) {
// 		l.Node = append(l.Node, r)
// 	}
// }

// func querySearch(r *html.Node, s Search, l *NodeList) {
// 	if r.Type == html.ElementNode {

// 		if len(s.Tag) > 0 {
// 			if s.Tag == r.Data {
// 				qSCompare(r, s, l)
// 			}
// 		} else if len(s.Attr) > 0 {
// 			qSCompare(r, s, l)
// 		}

// 	}
// 	for c := r.FirstChild; c != nil; c = c.NextSibling {
// 		querySearch(c, s, l)
// 	}
// }

// func qS(r []html.Attribute, s Search) bool {

// 	numToBeFound := len(s.Attr)
// 	for _, x := range r {
// 		for _, y := range s.Attr {
// 			if y.Name == x.Key {
// 				if y.Value == x.Val {
// 					numToBeFound--
// 				}
// 			}
// 		}
// 	}

// 	return numToBeFound == 0
// }
func (n *NodeList) append(r *html.Node) {
	n.Node = append(n.Node, Node{r})
}

func qSCompare(r *Node, s Search, l *NodeList) {
	if qS(r.Node.Attr, s) {
		l.append(r.Node)
	}
}

func querySearch(r *Node, s Search, l *NodeList) {
	// fmt.Println(r)
	if r.Node.Type == html.ElementNode {

		if len(s.Tag) > 0 {
			if s.Tag == r.Node.Data {
				qSCompare(r, s, l)
			}
		} else if len(s.Attr) > 0 {
			qSCompare(r, s, l)
		}

	}

	for c := r.Node.FirstChild; c != nil; c = c.NextSibling {
		x := r
		x.Node = c
		querySearch(x, s, l)
	}

}

func (n *Node) Text() string {
	b := &bytes.Buffer{}
	getText(n.Node, b)
	return b.String()
}



package speed

import (
	"bytes"
	"fmt"
	"io"

	"golang.org/x/net/html"
)

var (
	f func(x *html.Node)
)

// Node is the HTML document
// Nodelist are the pointer list to the nodes that the tag/selector has been searched for
// Simple struct to store relevant search data for the document
// NodeList will get wiped for each search. Searched Data can be saved after search is their is a return type (usually []/*html.Node)
type HTMLDocument struct {
	Main        *Node
	Node        *html.Node   //HTML DOC Node
	NodeList    []*html.Node // Current search result
	NewNodeList NodeList
}

type DocumentGroup struct {
	Collector []HTMLDocument
}

// Add to the doc struct for each HTML
func CreateHTMLDocument(r io.Reader) HTMLDocument {
	doc, err := html.Parse(r)
	if err != nil {
		fmt.Println("something")
	}
	return HTMLDocument{Node: doc, Main: &Node{doc}}
}

func (h *HTMLDocument) FindTag(element string, m ...func(doc *HTMLDocument)) []*html.Node {
	f = func(x *html.Node) {
		if x.Type == html.ElementNode && x.Data == element {
			h.NodeList = append(h.NodeList, x)
		}

		for c := x.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(h.Node)
	for _, x := range m {
		x(h)
	}
	return h.NodeList
}

func (h *HTMLDocument) Find(search string, m ...func(doc *HTMLDocument)) {
	s := FinderParser(search)
	l := &Tag{}
	// fmt.Println(FinderParser(search))
	AdvancedSearch(h.Node, *s, l)
	for _, x := range l.Node {
		for _, y := range x {
			h.NodeList = append(h.NodeList, y.Node)
		}
	}

	// return l.Node[
}

func (h *HTMLDocument) FindStrictly(search string, m ...func(doc *HTMLDocument)) {
	s := FinderParser(search)
	l := &Tag{}
	findStrictly(h.Node, *s, l)
	for _, x := range l.Node {
		for _, y := range x {
			h.NodeList = append(h.NodeList, y.Node)
		}
	}
	if len(m) > 0 {
		m[0](h)
	}

}

func (h *HTMLDocument) QuerySearch(search string) {
	s := FinderParser(search)
	nl := &NodeList{}
	// querySearch(h.Node, *s, nl)
	querySearch(h.Main, *s, nl)

	h.NewNodeList.Node = nl.Node
	// return nl.Node
}

func (h *HTMLDocument) Attr() []map[string]string {
	list := make([]map[string]string, 0)
	for _, x := range h.NodeList {
		t := make(map[string]string, 0)
		for _, y := range x.Attr {
			t[y.Key] = y.Val
		}
		list = append(list, t)
	}

	return list
}

func (h *HTMLDocument) GetAttr(elem ...string) []string {
	return getAttr(h.NodeList, false, elem)
}

func (h *HTMLDocument) GetAttrOnce(elem ...string) string {
	return getAttr(h.NodeList, true, elem)[0]
}

func getAttr(r []*html.Node, once bool, elem []string) []string {
	var list []string
	if once {
		list = make([]string, 0)
	}
	for _, x := range r {
		for _, y := range x.Attr {
			for _, z := range elem {
				if y.Key == z {
					if once {
						return []string{y.Val}
					}
					list = append(list, y.Val)
				}
			}
		}
	}
	return list
}

func (h *HTMLDocument) PrintNodes() {
	for _, x := range h.NodeList {
		fmt.Println(x)
	}
}

func Text(r *html.Node) string {
	b := &bytes.Buffer{}
	getText(r, b)
	return b.String()
}

func getText(r *html.Node, b *bytes.Buffer) {
	if r.Type == html.TextNode {
		b.WriteString(r.Data)
	}
	for c := r.FirstChild; c != nil; c = c.NextSibling {
		getText(c, b)
	}
}



package speed

import (
	"bytes"
	"fmt"
	"log"

	"golang.org/x/net/html"
)

type Tag struct {
	Name string
	Text [][]string
	Attr [][]Attribute
	Node [][]Node
}

type TagList struct {
	Tags map[string][]Tag
}

// ultra specific search struct
type SearchSpecifc struct {
	Tag  string
	Attr map[string]string
}

type SearchGroup struct {
	Group []Search
}

type Doc struct {
	Doc      *html.Node
	Tags     TagList
	NodeName string
}

// type Selectors struct {
// 	Type string
// 	Name string
// }

// works with the bytestream that naturally comes out of the Parse function
// adds it to the document list
func SetupDocument(bytestream *[]byte) Doc {
	b := *bytestream
	r, err := Parse(bytes.NewReader(b))
	if err != nil {
		log.Fatal("Failed to PARSE")
	}

	return AddtoDocument(r)
}

func AddtoDocument(r *html.Node) Doc {
	doc := Doc{Doc: r, NodeName: r.Data}
	DocumentList = append(DocumentList, doc)

	return doc
}

// Returns a list of tags and its data when found
// does depth first search
func SearchTag(h *html.Node, tag string) {
	if h.Type == html.ElementNode && h.Data == tag {
		fmt.Println("This tag has been found!")
	}
	// fmt.Println(h.Data)
	for c := h.FirstChild; c != nil; c = c.NextSibling {
		SearchTag(c, tag)
	}
}

func (r *Doc) SearchTag(tag string) []Tag {

	var dfs func(x *html.Node, data string)

	t := make([]Tag, 0)

	dfs = func(x *html.Node, data string) {
		// if x.Data == tag {
		// 	t = append(t, Tag{Text: x.Data})
		// }
		for c := x.FirstChild; c != nil; c = c.NextSibling {
			dfs(c, data)
		}
	}

	dfs(r.Doc, tag)

	return t
}

func FindAll(r *html.Node, t string, l *Tag) (*html.Node, bool) {
	if r.Type == html.ElementNode && r.Data == t {
		tmp := []Attribute{}
		for i := 0; i < len(r.Attr); i++ {
			attr := r.Attr[i]
			tmp = append(tmp, Attribute{Name: attr.Key, Value: attr.Val})
		}

		l.Attr = append(l.Attr, tmp)

		tmp = nil
	}
	for c := r.FirstChild; c != nil; c = c.NextSibling {
		FindAll(c, t, l)
	}

	return r, true
}

func GetTags(r *html.Node, s SearchSpecifc, l *Tag) {

	getTags(r, s, l)
}

func getTags(r *html.Node, s SearchSpecifc, l *Tag) *html.Node {

	isEmpty := false
	if !(len(s.Tag) > 0) {
		isEmpty = true
	}

	var f func(x *html.Node)
	var f_TagEmpty func(r *html.Node)

	f = func(x *html.Node) {
		if x.Type == html.ElementNode && x.Data == s.Tag {
			temp := []Attribute{}
			for i := 0; i < len(x.Attr); i++ {
				attr := x.Attr[i]
				if compareAttrandValue(attr, s) || s.Attr == nil {
					temp = append(temp, Attribute{Name: attr.Key, Value: attr.Val})
					addInnerHtml(x, l)
				}
			}

			if len(temp) > 0 {
				l.Attr = append(l.Attr, temp)
				temp = nil
			}

		}

		for c := x.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}

	f_TagEmpty = func(r *html.Node) {
		if r.Type == html.ElementNode {
			temp := []Attribute{}
			for i := 0; i < len(r.Attr); i++ {
				attr := r.Attr[i]
				if compareAttrandValue(attr, s) {
					temp = append(temp, Attribute{Name: attr.Key, Value: attr.Val})
					addInnerHtml(r, l)
				}
			}
			if len(temp) > 0 {
				l.Attr = append(l.Attr, temp)
				temp = nil
			}
		}
		for c := r.FirstChild; c != nil; c = c.NextSibling {
			f_TagEmpty(c)
		}
	}

	if isEmpty {
		f_TagEmpty(r)
	} else {
		f(r)
	}

	return r
}

func addInnerHtml(r *html.Node, l *Tag) {
	b := &bytes.Buffer{}
	collectText(r, b)
	l.Text = append(l.Text, []string{b.String()})
}

func collectText(r *html.Node, b *bytes.Buffer) {
	if r.Type == html.TextNode {
		b.WriteString(r.Data)
	}
	for c := r.FirstChild; c != nil; c = c.NextSibling {
		collectText(c, b)
	}
}

// func renderNode(r *html.Node) string {
// 	var buf bytes.Buffer
// 	w := io.Writer(&buf)
// 	html.Render(w, r)
// 	return buf.String()
// }
